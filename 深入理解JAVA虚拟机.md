# JVM

## 一  JAV内存区域

### 1.1 运行时数据区

#### 1.1.1 程序计数器

程序计数器用于记录当前线程执行的字节码的行号指示器。用于帮助线程切换后恢复到正确的执行的位置。每个线程都拥有一个独立的程序计数器，线程之间互不影响，独立存储。**线程私有**

#### 1.1.2  JVAV虚拟机栈

**线程私有**，生命周期与线程相同，当一个方法被执行的时候就会创建一个栈帧，用于存储 **局部变量表**，**操作栈，动态链接，方法出口**。当一个方法执行完成，就对应一个栈帧从虚拟机栈中抛出的过程。

如果线程请求的栈深度大于虚拟机所允许的最大深度，就会抛出一个 StackOverflow的异常。当扩展的时候无法申请内存就会抛出OutofMemoryError异常。

#### 1.1.3 本地方法栈

**线程私有**。本地方法栈和虚拟机栈差不多，只是存储的是本地方法的栈帧。

#### 1.1.4 Java堆

JAVA堆是JVM管理的最大的内存区域。**线程共享。**此区域存放的是对象的实例，几乎所有的对象实例都要在这里分配内存。堆空间也是垃圾收集器管理的主要区域。当无法完成实例的内存分配就会抛出OutofMemoryError异常。

#### 1.1.5 方法区

**线程共享。** 用于存储 **被虚拟机加载的类信息，常亮、静态变量、即时编译器后的代码数据。**

##### 1.1.5.1 运行时常量池

运行时常量池是属于方法区的一部分，Class文件 除了 类版本、字段、方法、接口等描述，还有一个是常量池。用于存放编译期间生成的各种字面量和符号引用。在类加载后存放到方法区的运行时常量池。

### 1.2 对象访问

#### 1.2.1 句柄

在JVM堆中会划分出一块内存来作为句柄池，reference中存储的是对象的句柄地址。句柄中则包含了对象实例数据和类型数据各自的具体地址信息。

#### 1.2.2 直接指针

如果使用直接指针的方法，reference中存储对象的地址。

#### 1.2.3 对比

使用句柄的优势reference中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而reference本身不需要被更改。

使用直接指针访问的话 好处就是速度快，节省了一次指针定位的时间。

## 二 垃圾收集器与内存分配策略

### 2.1 判断对象是否存活

#### 2.1.1 引用计数

实现： 给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就+1 ，当引用时效，计数器就-1。当计数器为0的时候对象就是不可能在被使用的。

问题： 无法解决循环引用。 当A引用B ，B引用A 。此时A,B两个对象都不在使用的时候就歇菜了。

#### 2.1.2 根搜索算法(gc roots tracing)

实现: 通过一些gc roots 的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径被称为引用链，当一个对象到GC roots 没有任何引用链相连，则证明对象是不可用的。

**GC ROOTS：**

* 虚拟机栈(本地变量表) 中引用的的对象
* 方法区中的类静态变量属性引用的对象
* 方法区中的常量引用的对象
* 本地方法栈中JNI 的引用的对象。

#### 2.1.3 引用

* 强引用: 程序代码中普遍存在的引用 类似 Object obj = new Object()  这要强引用存在，垃圾收集器就永远不会回收这些对象
* 软引用：用于描述一些还有用，但是不是必要的对象。软引用关联的对象，在系统发生OOM之前，会将这些对象拉入gc的范围进行第二次回收，如果这次回收还是没有足够的内存，才会抛出OOM。
* 弱引用：强度比软引用更弱。弱引用关联的对象智能生存在下次gc发生之前，当gc工作，无论内存是否足够都会回收。
* 虚引用：最弱的引用关系，无法通过引用过去对象实例，只是标志这个对象被回收之前，得到一个通知。

#### 2.1.4 Finalize

在根搜索中 ，没有与gc roots相连的对象在第一次标记并且进行一次筛选，判断对象是否有必要执行finalize方法，如果对象没有覆盖finalize方法或者已经被调用了，JVM都认为没有必要。如果认为有必要，就会被放入一个F-Queue的队列中，由一个低优先级的 Finalizer线程去执行。gc会将对F-Queue队列中的对象进行第二次小规模的标记，如果对象和别人挂钩了，那么就移除回收集合。

### 2.2 垃圾收集算法

